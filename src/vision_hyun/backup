// #include "../include/vision_hyun/vision_hyun.hpp"
// #include "autorace_interfaces/msg/vision_hyun.hpp"

// #include <thread>
// #include <mutex>
// #include <vector>
// #include <sys/socket.h>
// #include <arpa/inet.h>
// #include <unistd.h>
// #include <cstring>
// #include <cv_bridge/cv_bridge.h>
// #include <math.h>

// #define REMOTE_IP "223.194.43.153"
// #define REMOTE_PORT 9999 // UI용 포트 하나만 사용
// #define PACKET_SIZE 4096

// int udp_sock = -1;
// struct sockaddr_in remote_addr;

// void ImageViewer::send_udp_image(cv::Mat &img, int id)
// {
//     if (img.empty() || udp_sock < 0)
//     {
//         return;
//     }
//     cv::Mat resized;
//     cv::resize(img, resized, cv::Size(), 0.5, 0.5, cv::INTER_LINEAR);
//     std::vector<uchar> encoded;
//     std::vector<int> params = {cv::IMWRITE_JPEG_QUALITY, 40}; // 속도를 위해 50
//     bool success = cv::imencode(".jpg", resized, encoded, params);

//     if (!success)
//         return;

//     int total_size = encoded.size();

//     if (total_size == 0)
//         return;

//     int header[2] = {id, total_size};
//     sendto(udp_sock, header, sizeof(header), 0, (struct sockaddr *)&remote_addr, sizeof(remote_addr));

//     int sent_bytes = 0;
//     while (sent_bytes < total_size)
//     {
//         int chunk_size = std::min(PACKET_SIZE, total_size - sent_bytes);
//         ssize_t sent_chunk_bytes = sendto(udp_sock, &encoded[sent_bytes], chunk_size, 0, (struct sockaddr *)&remote_addr, sizeof(remote_addr));

//         if (sent_chunk_bytes < 0)
//             break;

//         sent_bytes += sent_chunk_bytes;

//         // 패킷 손실 방지를 위한 딜레이
//         usleep(1500);
//     }
// }

// void ImageViewer::udp_thread()
// {
//     while (rclcpp::ok())
//     {
//         cv::Mat f, b, t;
//         {
//             std::lock_guard<std::mutex> lock(frame_mutex);
//             f = udp_frame.clone();
//             b = udp_bird.clone();
//             t = udp_total.clone();
//         }

//         static int skip = 0;
//         if (++skip % 3 == 0)
//         {
//             send_udp_image(f, 0);
//             send_udp_image(b, 1);
//             send_udp_image(t, 2);
//         }

//         std::this_thread::sleep_for(std::chrono::milliseconds(33));
//     }
// }

// void ImageViewer::gui_thread()
// {
//     static int gui_skip = 0;
//     if (++gui_skip % 6 != 0)
//         return;

//     cv::Mat frame_display, bird_display, yellow_display, white_display,
//         red_and_green_mask_copy, brown_copy;
//     {
//         std::lock_guard<std::mutex> lock(frame_mutex);
//         if (!latest_frame.empty())
//             frame_display = latest_frame.clone();
//         if (!bird_copy.empty())
//             bird_display = bird_copy.clone();
//         if (!yellow_mask.empty())
//             yellow_display = yellow_mask.clone();
//         if (!white_mask.empty())
//             white_display = white_mask.clone();
//         if (!red_and_green_mask.empty())
//             red_and_green_mask_copy = red_and_green_mask.clone();
//         if (!brown_mask.empty())
//             brown_copy = brown_mask.clone();
//     }

//     if (!frame_display.empty())
//     {
//         std::stringstream ss;
//         ss << "Traffic Light flag : " << traffic_light_state;

//         cv::line(frame_display, cv::Point(320, 0), cv::Point(320, 360), cv::Scalar(0, 0, 255), 1);
//         cv::line(frame_display, cv::Point(0, 80), cv::Point(640, 80), cv::Scalar(0, 0, 255), 1);
//         cv::rectangle(
//             frame_display,
//             cv::Point(GUIdetect_x_start, GUIdetect_y_start),
//             cv::Point(GUIdetect_x_end, GUIdetect_y_end),
//             cv::Scalar(0, 255, 0), 2);

//         cv::putText(
//             frame_display,
//             ss.str(),
//             cv::Point(GUIdetect_x_start, GUIdetect_y_start - 5),
//             cv::FONT_HERSHEY_SIMPLEX,
//             0.5,
//             cv::Scalar(0, 255, 0),
//             1);

//         cv::imshow("Spedal Feed", frame_display);
//     }

//     if (!bird_display.empty())
//         cv::imshow("Bird's-Eye View", bird_display);
//     if (!yellow_display.empty())
//         cv::imshow("yellow_mask", yellow_display);
//     if (!white_display.empty())
//         cv::imshow("white_mask", white_display);
//     if (!red_and_green_mask_copy.empty())
//         cv::imshow("traffic_mask", red_and_green_mask_copy);
//     if (!brown_copy.empty())
//         cv::imshow("brown_mask", brown_copy);

//     cv::waitKey(1);
// }

// ImageViewer::ImageViewer()
//     : Node("vision_hyun_node")
// {
//     auto qos_profile = rclcpp::SensorDataQoS();
//     const std::string image_topic = "/default_camera/image_raw";

//     subscription_ = this->create_subscription<sensor_msgs::msg::Image>(
//         "/default_camera/image_raw",
//         rclcpp::SensorDataQoS(),
//         std::bind(&ImageViewer::image_callback, this, std::placeholders::_1));

//     publisher_ = this->create_publisher<sensor_msgs::msg::Image>("/vision/image_processed", 10);
//     publisher_2 = this->create_publisher<sensor_msgs::msg::Image>("/vision/birdeye_raw", 10);
//     publisher_3 = this->create_publisher<sensor_msgs::msg::Image>("/vision/birdeye_total", 10);
//     publisher_4 = this->create_publisher<autorace_interfaces::msg::VisionHyun>("/vision/line_diff_info", qos_profile);

//     cv::namedWindow("Spedal Feed");

//     cv::namedWindow("yellow_mask");
//     cv::namedWindow("white_mask");
//     cv::namedWindow("traffic_mask");
//     cv::namedWindow("brown_mask");
// }
// void ImageViewer::image_callback(const sensor_msgs::msg::Image::SharedPtr msg)
// {
    
//     cv::Mat frame = cv_bridge::toCvCopy(msg, "bgr8")->image;
//     if (frame.empty())
//         return;

   
//     process_birdeye(frame);
//     process_color_masks();
//     detect_traffic_light();
//     detect_lane_and_center();

//     {
//         std::lock_guard<std::mutex> lock(frame_mutex);

//         latest_frame = frame.clone();
//         bird_copy = birdeye_with_lines.clone();

//         udp_frame = latest_frame.clone();
//         udp_bird = birdeye_with_lines.clone();
//         udp_total = total_birdeye.clone();
//     }

   
//     publish_result(msg);
// }

// void ImageViewer::process_birdeye(const cv::Mat &frame)
// {
//     if (frame.empty())
//     {
//         RCLCPP_ERROR(this->get_logger(), "Input frame is empty in process_birdeye");
//         return;
//     }
//     // 버드아이 변환
//     cv::Point2f src_pts[4] = {
//         cv::Point2f(distort_L_top_x, distort_L_top_y) /*왼쪽 위*/,
//         cv::Point2f(distort_R_top_x, distort_R_top_y) /*오른쪽 위*/,
//         cv::Point2f(distort_L_under_x, distort_L_under_y) /*왼쪽 아래*/,
//         cv::Point2f(distort_R_under_x, distort_R_under_y) /*오른쪽 아래*/};

//     cv::Point2f dst_pts[4] = {
//         cv::Point2f(flat_L_top_x, flat_L_top_y),
//         cv::Point2f(flat_R_top_x, flat_R_top_y),
//         cv::Point2f(flat_L_under_x, flat_L_under_y),
//         cv::Point2f(flat_R_under_x, flat_R_under_y)}; // Z 모양임 순서가

//     cv::Mat M = cv::getPerspectiveTransform(src_pts, dst_pts);
//     cv::warpPerspective(frame, birdeye, M, cv::Size(640, 360));
//     if (birdeye.empty())
//     {
//         RCLCPP_ERROR(this->get_logger(), "Birdeye is empty after transformation");
//         return;
//     }
//     // 버드아이 > 가우시안 블러 적용
//     cv::GaussianBlur(birdeye, birdeye, cv::Size(5, 5), 1.5);
// }

// void ImageViewer::process_color_masks()
// {
//     if (birdeye.empty() || latest_frame.empty())
//     {
//         RCLCPP_WARN(this->get_logger(),
//                     "process_color_masks skipped (birdeye or latest_frame empty)");
//         return;
//     }

//     cv::Mat birdeye_hsv, frame_hsv;

//     // hsv 변환
//     cv::cvtColor(birdeye, birdeye_hsv, cv::COLOR_BGR2HSV);
//     cv::cvtColor(latest_frame, frame_hsv, cv::COLOR_BGR2HSV);

//     cv::inRange(birdeye_hsv, lower_brown, upper_brown, brown_mask);
//     cv::inRange(birdeye_hsv, lower_brown_2, upper_brown_2, brown_mask_2);
//     cv::add(brown_mask, brown_mask_2, brown_mask);

//     cv::inRange(birdeye_hsv, lower_white, upper_white, white_mask);
//     cv::inRange(birdeye_hsv, lower_yellow, upper_yellow, yellow_mask);

//     cv::Mat k = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(3, 3));
//     cv::dilate(yellow_mask, yellow_mask, k, cv::Point(-1, -1), 5);
//     cv::dilate(white_mask, white_mask, k, cv::Point(-1, -1), 5);
//     cv::dilate(brown_mask, brown_mask, k, cv::Point(-1, -1), 5);
//     // 신호등 감지 범위 및 플래그
//     /*
//     channels[0]  Blue 채널
//     channels[1]  Green 채널
//     channels[2]  Red 채널
//     */

//     // 아니 이거 신호등 불빛이 너무 강해서 hsv로 못따옴 그래서 bgr로 받아옴 에라이 시간만 날렸내
//     std::vector<cv::Mat> channels;
//     cv::split(latest_frame, channels); // BGR 형식으로 분리할 때 cv::split()

//     red_mask = (channels[2] > channels[0] + 30) &
//                (channels[2] > channels[1] + 30) &
//                (channels[2] > 150);

//     // 노이즈 제거
//     cv::Mat kernel = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));
//     cv::morphologyEx(red_mask, red_mask, cv::MORPH_OPEN, kernel);

//     cv::Mat green_temp_mask = (channels[1] > channels[0] + 30) &
//                               (channels[1] > channels[2] + 30) &
//                               (channels[1] > 100);

//     green_temp_mask.convertTo(green_mask, CV_8U, 255);
//     green_mask = green_temp_mask.clone();

//     red_and_green_mask = red_mask + green_mask;
// }

// void ImageViewer::detect_traffic_light()
// {
//     if (red_mask.empty() || green_mask.empty() || yellow_mask.empty())
//         return;

//     bar_red_pixel_count = 0;
//     red_pixel_count = 0;
//     yellow_pixel_count = 0;
//     green_pixel_count = 0;

//     detect_x_start = 320;
//     detect_y_start = 0;
//     detect_y_end = 250;

//     for (int i = detect_y_start; i < detect_y_end; i++)
//     {
//         for (int j = detect_x_start; j < detect_x_end; j++)
//         {
//             if (red_mask.at<uchar>(i, j) > 0)
//                 red_pixel_count++;
//             if (green_mask.at<uchar>(i, j) > 0)
//                 green_pixel_count++;
//             if (yellow_mask.at<uchar>(i, j) > 0)
//                 yellow_pixel_count++;
//         }
//     }

//     detect_x_start = 0;
//     detect_y_start = 90;
//     detect_y_end = 300;

//     for (int i = detect_y_start; i < detect_y_end; i++)
//     {
//         for (int j = detect_x_start; j < detect_x_end; j++)
//         {
//             if (red_mask.at<uchar>(i, j) > 0)
//                 bar_red_pixel_count++;
//         }
//     }

//     // 신호등 상태 판별
//     if (red_pixel_count > red_threshold)
//     {
//         traffic_light_state = 1;
//     }
//     else if (green_pixel_count > green_threshold)
//     {
//         traffic_light_state = 2;
//     }
//     else if (bar_red_pixel_count > bar_red_red_threshold) // 장애물 바 감지
//     {
//         traffic_light_state = 4;
//     }
//     else
//     {
//         traffic_light_state = 0;
//     }
// }
// void ImageViewer::publish_result(const sensor_msgs::msg::Image::SharedPtr msg)
// {
//     // 1. VisionHyun
//     autorace_interfaces::msg::VisionHyun info;
//     info.header = msg->header;
//     info.center_x = global_center_x;
//     info.yellow_x = global_yellow_x;
//     info.white_x = global_white_x;
//     info.traffic_light = traffic_light_state;
//     info.brown_count = brown_pixel_count;
//     info.yellowline_count = yellowline_pixel_count;
//     info.whiteline_count = whiteline_pixel_count;
//     publisher_4->publish(info);

//     // 2. 원본 처리 이미지
//     if (!latest_frame.empty())
//     {
//         auto img_msg = cv_bridge::CvImage(
//                            msg->header, "bgr8", latest_frame)
//                            .toImageMsg();
//         publisher_->publish(*img_msg);
//     }

//     // 3. 버드아이
//     if (!birdeye.empty())
//     {
//         auto bird_msg = cv_bridge::CvImage(
//                             msg->header, "bgr8", birdeye)
//                             .toImageMsg();
//         publisher_2->publish(*bird_msg);
//     }

//     // 4. 마스크 합성
//     if (!yellow_mask.empty() && !white_mask.empty())
//     {
//         cv::Mat total_color;
//         total_birdeye = yellow_mask + white_mask;
//         cv::cvtColor(total_birdeye, total_color, cv::COLOR_GRAY2BGR);

//         auto total_msg = cv_bridge::CvImage(
//                              msg->header, "bgr8", total_color)
//                              .toImageMsg();
//         publisher_3->publish(*total_msg);
//     }
// }
// void ImageViewer::detect_lane_and_center()
// {
//     if (brown_mask.empty() || yellow_mask.empty() || white_mask.empty() || birdeye.empty())
//     {
//         RCLCPP_WARN(this->get_logger(), "detect_lane_and_center skipped (empty mask)");
//         return;
//     }

//     brown_pixel_count = 0;
//     yellowline_pixel_count = 0;
//     whiteline_pixel_count = 0;

//     // 픽셀 카운트
//     for (int col = 0; col < brown_mask.cols; col++)
//     {
//         for (int row = 0; row < brown_mask.rows; row++)
//         {
//             if (brown_mask.at<uchar>(row, col) > 0)
//                 brown_pixel_count++;

//             if (row > line_d_top)
//             {
//                 if (yellow_mask.at<uchar>(row, col) > 0)
//                     yellowline_pixel_count++;
//                 if (white_mask.at<uchar>(row, col) > 0)
//                     whiteline_pixel_count++;
//             }
//         }
//     }

//     // 주차 구간 감지
//     if (whiteline_pixel_count > park_whiteLine_threshold)
//         traffic_light_state = 3;

//     // 버드아이 복사
//     birdeye_with_lines = birdeye.clone();

//     // 갈색 마스크 표시
//     for (int col = 0; col < brown_mask.cols; col++)
//     {
//         for (int row = 0; row < brown_mask.rows; row++)
//         {
//             if (brown_mask.at<uchar>(row, col) > 0)
//             {
//                 cv::line(birdeye_with_lines,
//                          cv::Point(col, row),
//                          cv::Point(col, row),
//                          cv::Scalar(255, 125, 125), 1);
//             }
//         }
//     }

//     global_center_x = -1;
//     global_yellow_x = -1;
//     global_white_x = -1;

//     // 중앙선 계산
//     for (int i = 0; i < yellow_mask.rows; i++)
//     {
//         yellow_x = -1;
//         white_x = -1;

//         // 노란색 라인
//         for (int j = 0; j < yellow_mask.cols; j++)
//         {
//             if (yellow_mask.at<uchar>(i, j) > 0)
//             {
//                 yellow_x = j;
//                 break;
//             }
//         }

//         // 흰색 라인
//         for (int j = white_mask.cols - 1; j >= 0; j--)
//         {
//             if (white_mask.at<uchar>(i, j) > 0)
//             {
//                 white_x = j;
//                 break;
//             }
//         }

//         center_y = -1;
//         center_w = -1;
//         center_yw = -1;

//         if (yellow_x != -1 && white_x != -1)
//             center_yw = (yellow_x + white_x) / 2;
//         if (yellow_x != -1)
//             center_y = yellow_x + 235;
//         if (white_x != -1)
//             center_w = white_x - 235;

//         //  안전 체크
//         if (center_yw >= 0 && center_yw < birdeye_with_lines.cols)
//         {
//             cv::line(birdeye_with_lines,
//                      cv::Point(center_yw, i),
//                      cv::Point(center_yw, i),
//                      cv::Scalar(0, 255, 0), 1);

//             if (i == detect_line &&
//                 detect_line >= 0 &&
//                 detect_line < yellow_mask.rows)
//             {
//                 global_center_x = center_yw;
//             }
//         }

//         if (center_y >= 0 && center_y < birdeye_with_lines.cols)
//         {
//             cv::line(birdeye_with_lines,
//                      cv::Point(center_y, i),
//                      cv::Point(center_y, i),
//                      cv::Scalar(255, 255, 0), 1);

//             if (i == detect_line &&
//                 detect_line >= 0 &&
//                 detect_line < yellow_mask.rows)
//             {
//                 global_yellow_x = center_y;
//             }
//         }

//         if (center_w >= 0 && center_w < birdeye_with_lines.cols)
//         {
//             cv::line(birdeye_with_lines,
//                      cv::Point(center_w, i),
//                      cv::Point(center_w, i),
//                      cv::Scalar(255, 255, 255), 1);

//             if (i == detect_line &&
//                 detect_line >= 0 &&
//                 detect_line < yellow_mask.rows)
//             {
//                 global_white_x = center_w;
//             }
//         }
//     }

//     bird_copy = birdeye_with_lines.clone();

//     // 기준선 표시
//     cv::line(birdeye_with_lines,
//              cv::Point(birdeye_with_lines.cols * 0.75, 0),
//              cv::Point(birdeye_with_lines.cols * 0.75, birdeye_with_lines.rows),
//              cv::Scalar(0, 0, 255), 1);

//     cv::line(birdeye_with_lines,
//              cv::Point(birdeye_with_lines.cols * 0.25, 0),
//              cv::Point(birdeye_with_lines.cols * 0.25, birdeye_with_lines.rows),
//              cv::Scalar(0, 0, 255), 1);

//     if (detect_line >= 0 && detect_line < birdeye_with_lines.rows)
//     {
//         cv::line(birdeye_with_lines,
//                  cv::Point(0, detect_line),
//                  cv::Point(640, detect_line),
//                  cv::Scalar(255, 0, 255), 3);
//     }

//     if (global_center_x >= 0)
//     {
//         cv::putText(birdeye_with_lines,
//                     "C:" + std::to_string(global_center_x),
//                     cv::Point(10, 80),
//                     cv::FONT_HERSHEY_SIMPLEX,
//                     0.5,
//                     cv::Scalar(0, 255, 0), 2);

//         cv::circle(birdeye_with_lines,
//                    cv::Point(global_center_x, detect_line),
//                    5,
//                    cv::Scalar(0, 0, 255), -1);
//     }
// }

// int main(int argc, char *argv[])
// {
//     rclcpp::init(argc, argv);

//     udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
//     if (udp_sock < 0)
//     {
//         std::cerr << "소켓 생성 실패" << std::endl;
//         return 1;
//     }

//     memset(&remote_addr, 0, sizeof(remote_addr));
//     remote_addr.sin_family = AF_INET;
//     remote_addr.sin_port = htons(REMOTE_PORT);
//     inet_pton(AF_INET, REMOTE_IP, &remote_addr.sin_addr);

//     auto node = std::make_shared<ImageViewer>();

//     // UDP만 스레드
//     std::thread udp_t(&ImageViewer::udp_thread, node.get());

//     rclcpp::WallRate rate(30);

//     while (rclcpp::ok())
//     {
//         rclcpp::spin_some(node);
//         node->gui_thread();
//         rate.sleep();
//     }

//     udp_t.join();

//     rclcpp::shutdown();
//     close(udp_sock);
//     cv::destroyAllWindows();
//     return 0;
// }
